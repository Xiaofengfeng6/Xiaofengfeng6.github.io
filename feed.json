{"title":"Xiaoguo's Blog","description":"Stay silly,stay curious,like a child.","language":"","link":"//xueningyun.github.io","pubDate":"Tue, 21 Apr 2020 05:15:00 GMT","lastBuildDate":"Tue, 21 Apr 2020 10:15:18 GMT","generator":"hexo-generator-json-feed","webMaster":"雪柠云","items":[{"title":"排序算法","link":"//xueningyun.github.io/2020/04/21/paixu/","description":"选择排序简单选择排序，通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录交换之，即从第一个数据开始，进行比较，找出最小值，第二次从第二个数据开始，以此类推。C语言代码如下(其中Sqlist为结构体定义，由数组和数组长度构成)： 123456789101112131415161718192021void SelectSort(Sqlist *L)&#123; int i,j,min; for(i=0;i&lt;L-&gt;length;i++) &#123; min=i; for(j=i+1;j&lt;=L-&gt;length;j++) &#123; if(L-&gt;r[min]&gt;L-&gt;r[j]) min=j; &#125; &#125; if(i!=min) swap(L,i,min);&#125;void swap(Sqlist *L,int i,int j)&#123; int temp=L-&gt;r[i]; L-&gt;r[i]=L-&gt;r[j]; L-&gt;r[j]=temp;&#125; 冒泡排序两两比较相邻记录的关键字，如果反序则交换，直到没有反序记录为止。 1234567891011121314void BubbleSort(Sqlist *L)&#123; int i,j; for(i=0;i&lt;L-&gt;length;i++) &#123; for(j=L-&gt;length;j&gt;=i;j--) &#123; if(L-r[j]&gt;L-r[j+1]) &#123; swap(L,j,j+1); &#125; &#125; &#125;&#125; 插入排序将一个记录插入到一个有序表中，从而得到一个新的有序表。 1234567891011121314151617void InsertSort(Sqlist *L)&#123; int i,j; int x; //设置哨兵 for(i=1;i&lt;L-&gt;length;i++) &#123; if(L-&gt;r[i]&lt;L-&gt;r[i-1]) &#123; x=L-&gt;r[i]; for(j=i-1;L-&gt;r[j]&gt;x;j--) &#123; L-&gt;r[j+1]=L-&gt;r[j]; &#125; L-&gt;r[j+1]=x; &#125; &#125;&#125; 并归排序利用分治思想，将n个记录的序列，一层层对半分层两个子序列，最终得到[n/2]个长度为2或者1的有序子序列，再两两并归，最终得到长度n的有序序列。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*num[]为需排序的序列，tum[]为排序后的序列，first为序列起点，last为序列尾点*/void mergeSort(int *num,int first,int last,int *tum)&#123; if(first&lt;last) &#123; int mid; mid=(last-first)/2+first; mergeSort(num,first,mid,tum); mergeSort(num,mid+1,last,tum); mergetow(num,first,mid,last,tum); &#125;&#125;void mergetow(int *num,int first,int mid,int last,int *tum)&#123; int i,j,n,m; int k=0; i=first; j=mid+1; n=mid+1; m=last+1; while(i&lt;n&amp;&amp;j&lt;m) &#123; if(num[i]&lt;num[j]) &#123; tum[k++]=num[i++]; &#125; else &#123; tum[k++]=num[j++]; &#125; &#125; while(i&lt;n)//将剩余的num[]元素复制到tum中 &#123; tum[k++]=num[i++]; &#125; while(j&lt;m) &#123; tum[k++]=num[j++]; &#125; for (i = 0; i &lt; k; i++) &#123; num[first + i] = tum[i]; &#125;&#125; 快速排序采用分治思想，将序列进行分割，即划分交换。基本思想为：1、先从数列中取出一个数作为基准数。2、分区，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。3、对左右区间重复第二步，直到各区间只有一个数。有一个很形象的描述，就是：挖坑填数+分治法。1、如示例数组，取区间第一个数为基准数。 2、有基准数后，便进行分区，将小于或等于a0放在左边，大于a[0]放在右边。分区过程，即挖坑填数。初始时，i = 0; j = 9; e = a[i] = 72。由于已经将a[0]中的数保存到e中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。从j开始（即数组的终端，最右边开始）向前找一个比e小或等于e的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。坑a[0]被填好，又产生了一个新坑a[8]，所以接着找数字来填a[8]这个坑。这次从i开始向后找一个大于e的数，当i=3，符合条件，将a[3]挖出填到上一个坑a[8]中。数组变为： 此时，i=3，j=7,e=72。3、重复步骤2，挖的坑大于基准数则从后向前找，坑小于基准数则由前往后找。4、直到i=j时，退出，本例中i=j=5时退出，此时坑为a[5],并将e填入坑a[5]。数组变为： 由上图，a[5]左边的数都小于它，右边的数都大于它。5、以a[5]为界划分为左右两个数组子区间，然后再对左右两个子区间a[0~4]、a[6~9]重复1、2、3、4步骤，直到排序完成。C语言代码如下： 123456789101112131415161718192021222324252627282930void quick_sort(int *num,int L,int H)&#123; if(L&lt;H) &#123; int i=L; int j=H; int e=num[L]; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;num[j]&gt;=e) &#123; j--; &#125; if(i&lt;j) &#123; num[i++]=num[j]; &#125; while(i&lt;j&amp;&amp;num[i]&lt;e) &#123; i++; &#125; if(i&lt;j) &#123; num[j--]=num[i]; &#125; &#125; num[i]=e; quick_sort(num,L,i-1); quick_sort(num,i+1,H); &#125;&#125; 参考文献 陈杰 《大话数据结构》 白话经典算法系列之六 快速排序 快速搞定 CSDN","pubDate":"Tue, 21 Apr 2020 05:15:00 GMT","guid":"//xueningyun.github.io/2020/04/21/paixu/","category":"学习笔记"},{"title":"计算机网络笔记","link":"//xueningyun.github.io/2020/04/17/jsjwl/","description":"为韩立刚老师计算机网络课程学习笔记","pubDate":"Fri, 17 Apr 2020 13:36:00 GMT","guid":"//xueningyun.github.io/2020/04/17/jsjwl/","category":"学习笔记"},{"title":"数据结构笔记","link":"//xueningyun.github.io/2020/04/09/sjjg/","description":"写在前面：个人学习笔记。","pubDate":"Thu, 09 Apr 2020 06:24:29 GMT","guid":"//xueningyun.github.io/2020/04/09/sjjg/","category":"学习笔记"},{"title":"C语言笔记","link":"//xueningyun.github.io/2020/04/07/C/","description":"写在前面：个人学习笔记。","pubDate":"Tue, 07 Apr 2020 14:46:29 GMT","guid":"//xueningyun.github.io/2020/04/07/C/","category":"学习笔记"},{"title":"FFT简述","link":"//xueningyun.github.io/2019/03/13/FFT/","description":"写在前面：水平有限，经供参考。","pubDate":"Wed, 13 Mar 2019 12:46:29 GMT","guid":"//xueningyun.github.io/2019/03/13/FFT/","category":"学习笔记"},{"title":"晶振电路概述","link":"//xueningyun.github.io/2019/03/13/COC/","description":"写在前面：本文参考资料大多数来自于TI官网，结合笔者实际在制作经验所写。水平有限，欢迎指正。","pubDate":"Wed, 13 Mar 2019 12:46:29 GMT","guid":"//xueningyun.github.io/2019/03/13/COC/","category":"学习笔记"},{"title":"手机拍照","link":"//xueningyun.github.io/2019/02/12/Phone_photo/","description":"突出主题，色彩协调，画面简洁。","pubDate":"Tue, 12 Feb 2019 07:00:00 GMT","guid":"//xueningyun.github.io/2019/02/12/Phone_photo/","category":"凡间角落"},{"title":"读书笔记","link":"//xueningyun.github.io/2019/01/19/study_notes/","description":"读书笔记，收录书单。","pubDate":"Sat, 19 Jan 2019 02:15:29 GMT","guid":"//xueningyun.github.io/2019/01/19/study_notes/","category":"凡间角落"},{"title":"NE564","link":"//xueningyun.github.io/2019/01/19/NE564/","description":"仅供参考，应用时请仔细阅读英文数据手册","pubDate":"Sat, 19 Jan 2019 02:13:29 GMT","guid":"//xueningyun.github.io/2019/01/19/NE564/","category":"学习笔记"},{"title":"电影小栈","link":"//xueningyun.github.io/2019/01/19/movie_house/","description":"收录看过的好电影。","pubDate":"Sat, 19 Jan 2019 02:13:29 GMT","guid":"//xueningyun.github.io/2019/01/19/movie_house/","category":"凡间角落"},{"title":"CD74HC7046","link":"//xueningyun.github.io/2019/01/09/CD74HC7046/","description":"仅供参考，应用时请仔细阅读英文数据手册","pubDate":"Wed, 09 Jan 2019 14:13:29 GMT","guid":"//xueningyun.github.io/2019/01/09/CD74HC7046/","category":"学习笔记"}]}